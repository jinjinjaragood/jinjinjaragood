module zero_padding_second #(
    parameter DATA_WIDTH = 32,
    parameter WIDTH = 5,
    parameter HEIGHT = 5,
    parameter PAD_WIDTH = 7,
    parameter PAD_HEIGHT = 7
)(
    input logic clk,
    input logic rst_n,
    input logic valid,
    input logic [DATA_WIDTH-1:0] buffer0 [0:HEIGHT-1][0:WIDTH-1],
    input logic [DATA_WIDTH-1:0] buffer1 [0:HEIGHT-1][0:WIDTH-1],
    output logic [DATA_WIDTH-1:0] padded0 [0:PAD_HEIGHT-1][0:PAD_WIDTH-1],
    output logic [DATA_WIDTH-1:0] padded1 [0:PAD_HEIGHT-1][0:PAD_WIDTH-1],
    output logic valid_padding // 패딩 완료 신호
);

    // 패딩 작업을 위한 내부 변수
    logic [DATA_WIDTH-1:0] zero_padding [0:PAD_HEIGHT-1][0:PAD_WIDTH-1];
    integer i, j;

    // 패딩 작업
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // 리셋 상태
            valid_padding <= 0;
            for (i = 0; i < PAD_HEIGHT; i = i + 1) begin
                for (j = 0; j < PAD_WIDTH; j = j + 1) begin
                    padded0[i][j] <= 0;
                    padded1[i][j] <= 0;
                end
            end
        end else if (valid) begin
            // 패딩 작업 수행
            for (i = 0; i < HEIGHT; i = i + 1) begin
                for (j = 0; j < WIDTH; j = j + 1) begin
                    padded0[i+1][j+1] <= buffer0[i][j]; // 위아래, 좌우로 1칸씩 이동
                    padded1[i+1][j+1] <= buffer1[i][j];
                end
            end

            // 나머지 부분 제로로 채우기
            for (i = 0; i < PAD_HEIGHT; i = i + 1) begin
                for (j = 0; j < PAD_WIDTH; j = j + 1) begin
                    if (i < HEIGHT+2 && j < WIDTH+2) begin
                        // 이미 채워진 데이터
                        // padded0[i][j] 및 padded1[i][j] 값은 위에서 설정됨
                    end else begin
                        // 나머지 부분 제로로 설정
                        padded0[i][j] <= 0;
                        padded1[i][j] <= 0;
                    end
                end
            end

            // 패딩 완료 신호를 1로 설정
            valid_padding <= 1;
        end
    end

endmodule
